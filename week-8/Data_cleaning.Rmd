---
title: "Data cleaning for IMDB data set"
subtitle: "Week - 8"
author: "Viki-Misi"
date: "November 11, 2021"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
---

```{r, include=F}
library(tidyverse)
library(data.table)
library(janitor)
library(kableExtra)

my_path <- "/Users/MViki/Documents/Jobs/CEU_R_Mentoring/ECBS-5163-Coding-Practice-with-R/week-8/Data/"
```



## Get the data

You can get the data from [Github](https://github.com/misrori/ceu-ba-mentoring-priv/tree/2021-2022/week-7/Data).

```{r, include=F}

df1 <- read.csv('https://raw.githubusercontent.com/misrori/ECBS-5163-Coding-Practice-with-R/master/week-8/Data/IMDB_top200.csv')

df2 <- read.csv('https://raw.githubusercontent.com/misrori/ECBS-5163-Coding-Practice-with-R/master/week-8/Data/IMDB_50.csv')

```

## Merge the data sets

We have our data in two tables, so lets merge them together.

```{r, include=F}

df <- rbind(df1, df2)

```


## Drop unnecessary columns

Delete the followings:

* everything with *tomato*
* Poster
* Website
* Response
* imdbID

```{r, include=F}
df <- df %>% 
  select(-c(Poster, tomatoMeter, tomatoImage, tomatoRating, tomatoReviews, tomatoFresh, tomatoRotten, tomatoConsensus, tomatoUserMeter, tomatoUserRating, tomatoUserReviews, tomatoURL, Website, Response, imdbID))
```


## Deal with column names

Rename some columns

* *X* to **IMDB_rank**
* *Runtime* to **Lengt_min**

Make sure all names are lower case and are separeted by _ in case needed.

<details>
  <summary>Hint</summary>
  Check out **janitor** package.
</details>
  
```{r, include=F}
df <- df %>% 
  rename(IMDB_rank = X,
         Length_min = Runtime)

df <- df %>% 
  clean_names()

```


## Change data types

`relesed` and `dvd` should be dates

<details>
  <summary>Hint</summary>
  For `dvd` you must delete the ° before transforming to data format.
</details>

```{r, include=F}
df$released <- as.Date(df$released, format = "%d %b %Y")

# For dvd we also have to delete the ° before changing the data type
df$dvd <- gsub("°", "", df$dvd)
df$dvd <- as.Date(df$dvd, format = "%B/%Y/%d")
        
```

The `IMDB rank` should be NOT numeric.

```{r, include=F}

df$imdb_rank <- as.character(df$imdb_rank)

```


`metascore`, `imdb_votes` and `box office` should be numeric.

<details>
  <summary>Hint 1</summary>
  Keep only numbers in the column.
</details>

<details>
  <summary>Hint 2</summary>
  Substitute N/A values with the proper ones.
</details>



```{r, include=F}

df$metascore <- as.numeric(df$metascore)
df$imdb_votes <- as.numeric(gsub( "[^0-9\\.]", "", df$imdb_votes))
df$box_office <- as.numeric(gsub("[^0-9\\.]", "", gsub("N/A", NA, df$box_office)))

```


## Start looking at columns

#### `released` 

This should be kept but also separated to year, month and day.

```{r, include=F}

df$released_to_sep <- df$released

df <- separate(df, released_to_sep, c("year_2", "month", "day"), sep = "-")
df$year_2 <- NULL
df$month <- as.numeric(df$month)
df$day <- as.numeric(df$day)

```


#### `length_min`

This should be numeric, without the *min* word.

```{r, include=F}

df$length_min <- as.numeric(gsub("min", "", df$length_min))

```


#### `genre`

There are 1, 2 or 3 genre given for a film, to be able to deal with this we need them in different columns. Also pay attention to extra white spaces!

```{r, include=F}

df <- separate( df, genre, "," , into = c("genre_1", "genre_2", "genre_3") )

df$genre_2 <- trimws(df$genre_2)
df$genre_3 <- trimws(df$genre_3)

```

#### `director`

Keep only the first one listed.

```{r, include=F}

df <- separate(df, director, "," , into = c("director") )

```

#### `writer`

Keep only the first one listed and do NOT keep anything in ()! 

<details>
  <summary>Hint</summary>
  You need to gsub the first ( with # and keep only the part before that.
</details>



```{r, include=F}

df <- separate( df, writer, "," , into = c("writer") )

# Keep only names and delete things within ()
df$writer <- gsub("(", "#", df$writer, fixed = TRUE)
df <- separate( df, writer, "#" , into = c("writer") )

```

#### `language`

Keep only the first one listed.

```{r, include=F}

df <- separate( df, language, "," , into = c("language"))

```

#### `country`

Keep only the first one listed.

```{r, include=F}

df <- separate( df, country , "," , into = c("country"))

```

#### `ratings_value`

Should be numeric so /10  is not needed.

```{r, include=F}
df <- separate( df, ratings_value , "/" , into = c("ratings_value") )
df$ratings_value <- as.numeric(df$ratings_value)
```


#### `Awards`

This will be the difficult part.

As a first step create 4 new columns:

* wins
* nominations
* oscars
* oscar nominations

```{r, include=F}

df$wins <- 0
df$nominations <- 0
df$oscars <- 0
df$oscar_nomination <- 0

```


Create 4 functions to extract the number from the text in the `awards` column. 

<details>
  <summary>Hint 1</summary>
  Use `grepl()` to determine if the word *wins/nominations.|nomination./Won&Oscar/Nominated&Oscar* are in the text.
</details>

<details>
  <summary>Hint 2</summary>
  Use `strsplit()` to create a list of the words.
</details>

<details>
  <summary>Hint 3</summary>
  Make sure you deal with *wins.* vs *wins* or *nominations.* vs *nomination.*.
</details>

<details>
  <summary>Hint 4</summary>
  Use `which()` to find on which place the searched word (*wins/nominations./Won/Nominated*) is, and return the value from the list before this. In case the searched word is not in the sentence return NA.
</details>


```{r, include=F}
get_wins <- function(t) {
 if (grepl("wins", t)) {
   pieces <- strsplit(t," ", fixed = TRUE)[[1]]
   pieces <- gsub("wins.","wins", pieces)
   return(as.numeric(pieces[which(pieces == "wins")-1]))  
 } else {
   return(NA)
 }
}

get_nominations <- function(t) {
  if (grepl("nominations.", t) | grepl("nomination.", t) ) {
    pieces <- strsplit(t," ", fixed = TRUE)[[1]]
    pieces <- gsub("nomination.","nominations.", pieces, fixed = TRUE)
    return(as.numeric(pieces[which(pieces == "nominations.")-1]))  
  } else {
    return(NA)
  }
}

get_oscar <- function(t) {
  if (grepl("Won", t) & grepl("Oscar", t) ){
    pieces <- strsplit(t, " ", fixed = TRUE)[[1]]
    return(as.numeric(pieces[which(pieces == "Won") + 1]))
  } else{
    return(NA)
  }
}

get_oscar_nominations <- function(t) {
  if (grepl("Nominated", t) & grepl("Oscar", t) ){
    pieces <- strsplit(t, " ", fixed = TRUE)[[1]]
    return(as.numeric(pieces[which(pieces == "Nominated") + 2]))
  } else{
    return(NA)
  }
}

```


Loop through the rows of the data frame and get the number of wins and nominations in the 4 predefined columns using the functions created.

```{r, include=F}

for (i in 1:nrow(df)) {
  df$oscar_nomination[i] <- get_oscar_nominations(df$awards[i])
  df$oscars[i] <- get_oscar(df$awards[i])
  df$nominations[i] <- get_nominations(df$awards[i])
  df$wins[i] <- get_wins(df$awards[i])
}

```


### Nice jooob, you are done with cleaning

You can now cheer a bit :D

```{r, include=F}

df %>% 
  head(10) %>% 
  kbl() %>% 
  kable_classic(full_width=F)

```


## Save the cleaned file

Last step is always to save the cleaned data in a format that is useful later.

```{r, include=F}

write.csv(df, paste0(my_path, 'IMDB_clean.csv'))

```


# Data.table

We will look at data.table package.

For this the first step is to transfer the data frame to a data.table format.

```{r}
df <- data.table(df)
```

Alternatively you can read your data with `fread()` instead of `read.csv()` or `read_csv()`

## Filter rows

You can filter rows by their number. This gives the first 5 rows of the df.

```{r}
dim(df[1:5])
```

You can add a , after the number to make sure you filter for rows. If you do so for a data frame that is not a data.table, this makes sure that you filter for rows, if you do not include, it will filter for columns.

```{r}

dim(df1[1:5])
dim(df1[1:5,])

```


The power of data.table lies in the ease of filtering and arranging and calculating new values.

First lets talk about filtering. Instead of including numbers you can filter by setting the values. For example this will filter the data frame to only the rows where the length of the film is more than 160 minutes. 

```{r}

df[length_min > 160][1:10,1:5] %>% kbl()

```

You can chain your filters by **&** or **|**.

```{r}

df[length_min > 160 & metascore < 90][,1:5] %>% kbl()

```


#### Task 1

Filter your data frame for only the films that were released after 2000 and their rating is above 8.5.

```{r, echo=F}
df[year > 2000 & ratings_value > 8.5][,1:5] %>% kbl()
```


#### Task 2 

Lets look at the ones that are not from the USA, won any Oscars or had any Oscar nominations.

```{r, echo=F}

df[country != 'USA' & (oscars > 0 | oscar_nomination > 0)][,1:5]  %>% kbl()

```


#### Task 3

Now filter for the ones that are adventure from the Warner Brothers and we have box office info for them.

```{r, echo=F}

df[(genre_1 == 'Adventure' | genre_2 == 'Adventure' | genre_3 == 'Adventure') & tolower(production) %like% 'warner.' & !is.na(box_office)][,1:5] %>% kbl()  

```


## Select or calculate columns

`df[filter, select or calculate,...]`

As the second variable for in the [] you can select given columns from the data. You have to use `list()` or `.()`.

```{r}

df[1:10, list(title, length_min, ratings_value)] %>% 
  kbl()

```

You can also rename the columns like:

```{r}

df[1:10, .('Film title' = title, 
              'Length of the movie' = length_min, 
              'IMDB Rating' = ratings_value)] %>% 
  kbl()

```

With using the `order()` function you can also reorder the values based on the values in one column.

```{r}

df[1:10, list('Film title' = title, 
              'Length of the movie' = length_min, 
              'IMDB Rating' = ratings_value)][order(-`Length of the movie`)] %>% 
  kbl()

```


The most cool thing here is that you can really easily calculate stuff here. It can be one value.

The number of films that are longer than 160 minutes.

```{r}

df[length_min > 160, .N]

```

Or the mean rating for these.

```{r}

df[length_min > 160, mean(ratings_value)]

```

#### Task 4

Calculate the mean length of the films that were produced between 1990 and 2000 and has won an award.

```{r, echo=F}

df[year >= 1990 & year <= 2000 & awards > 0, mean(length_min)]

```

#### Task 5

Calculate the minimum, maximum and the mean box office revenue for films with more than 1000000 imbd votes and are rating R.

```{r, echo=F}

df[imdb_votes >= 1000000 & rated == 'R', mean(box_office, na.rm = T)]

```

#### Task 6


## Group by

`df[filter, select or calculate, group by]`

The next functionality we are covering is group by. This is the third part in the []. You can group your data by a choosen criteria by just putting it into the `by = ` variable.

```{r}

df[, .(num_films = .N), by = production][order(-num_films)][1:10] %>% 
  kbl()

```


#### Task 7



#### Task 8



#### Task 9








